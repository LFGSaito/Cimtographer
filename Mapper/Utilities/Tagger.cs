using ColossalFramework;
using Mapper.Containers;
using Mapper.Managers;
using Mapper.OSM;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Mapper.Utilities
{
    public static class Tagger
    {
        /// <summary>
        /// Returns a list of tags associated with the NetSegment passed in
        /// </summary>
        /// <param name="segment">The segment to generate tags for</param>
        /// <param name="wayTags">The tags associated with the segment</param>
        /// <returns>Whether any tags were found</returns>
        public static bool CreateWayTags(NetSegment segment, out List<OSMWayTag> wayTags)
        {
            wayTags = new List<OSMWayTag>();

            bool success = false;
            string segmentName = segment.Info.name;

            foreach(RoadContainer road in RoadManager.GetAllRoadTypes())
            {
                if(road.RoadNameMatches(segmentName))
                {
                    wayTags.AddRange(road.tags);
                    success = true;
                }
            }

            if(success)
            {
                wayTags.AddRange(AddExtendedWayTags(segment));
            }

            return success;
        }

        /// <summary>
        /// Adds tags that can't be evaluated through a normal search
        /// </summary>
        /// <param name="segment">The segment to generate extended tags for</param>
        /// <returns>A list of tags generated from this segment</returns>
        public static List<OSMWayTag> AddExtendedWayTags(NetSegment segment)
        {
            List<OSMWayTag> returnList = new List<OSMWayTag>();

            ushort startNodeId = segment.m_endNode;
            ushort endNodeId = segment.m_startNode;

            NetManager netManager = Singleton<NetManager>.instance;
            NetNode startNode = netManager.m_nodes.m_buffer[startNodeId];
            NetNode endNode = netManager.m_nodes.m_buffer[endNodeId];

            byte wayElevation = (byte)(Mathf.Clamp((startNode.m_elevation + endNode.m_elevation) / 2, 0, 255));
            bool wayUnderground = startNode.m_flags.IsFlagSet(NetNode.Flags.Underground) || endNode.m_flags.IsFlagSet(NetNode.Flags.Underground);

            if (wayUnderground && MapperOptionsManager.OptionChecked("tunnels", MapperOptionsManager.exportOptions))
            {
                returnList.Add(new OSMWayTag { k = "tunnel", v = "yes" });
                returnList.Add(new OSMWayTag { k = "level", v = (-Mathf.FloorToInt(wayElevation / 12)).ToString() });
                returnList.Add(new OSMWayTag { k = "layer", v = (-Mathf.FloorToInt(wayElevation / 12)).ToString() });
            }
            else if (wayElevation != 0 && MapperOptionsManager.OptionChecked("bridges", MapperOptionsManager.exportOptions))
            {
                returnList.Add(new OSMWayTag { k = "bridge", v = "yes" });
                returnList.Add(new OSMWayTag { k = "level", v = Mathf.FloorToInt(wayElevation / 12).ToString() });
                returnList.Add(new OSMWayTag { k = "layer", v = Mathf.FloorToInt(wayElevation / 12).ToString() });
            }

            return returnList;
        }

        /// <summary>
        /// Returns a list of tags associated with the Building passed in
        /// </summary>
        /// <param name="building">The building to generate tags for</param>
        /// <param name="buildingTags">The tags generated by this building</param>
        /// <returns>Whether any tags were generated</returns>
        public static bool CreateBuildingTags(Building building, out List<OSMWayTag> buildingTags)
        {
            buildingTags = new List<OSMWayTag>();

            ItemClass.Service buildingService = building.Info.m_class.m_service;
            ItemClass.SubService buildingSubService = building.Info.m_class.m_subService;

            string buildingClassName = building.Info.m_class.name.ToLower().Replace(" ", "");
            string buildingIngameName = CleanUpName(building.Info.name);

            foreach (BuildingContainer buildingContainer in Managers.BuildingManager.buildings)
            {
                if (buildingContainer.linkedOption == "" || MapperOptionsManager.OptionChecked(buildingContainer.linkedOption, MapperOptionsManager.exportOptions))
                {
                    List<OSMWayTag> containerTags = new List<OSMWayTag>();
                    bool validComparisons = true;

                    foreach (ItemInversionContainer<string> buildingContainerClassName in buildingContainer.buildingClassNames)
                    {
                        string lowerClassName = buildingContainerClassName.storedItem_.ToLower().Replace(" ", "");

                        if ((buildingClassName.Contains(lowerClassName) && buildingContainerClassName.validation_ == ItemInversionContainer<string>.ValidationType.None) ||
                            (!buildingClassName.Contains(lowerClassName) && buildingContainerClassName.validation_ == ItemInversionContainer<string>.ValidationType.Inverted))
                        {
                            containerTags.AddRange(buildingContainer.tags);
                        }
                        else
                        {
                            validComparisons = false;
                        }
                    }

                    foreach (ItemInversionContainer<ItemClass.Service> buildingContainerService in buildingContainer.buildingServices)
                    {
                        if (buildingContainerService.storedItem_ == buildingService && buildingContainerService.validation_ == ItemInversionContainer<ItemClass.Service>.ValidationType.None)
                        {
                            containerTags.Clear();
                            containerTags.AddRange(buildingContainer.tags);
                        }
                        else
                        {
                            validComparisons = false;
                        }
                    }

                    foreach (ItemInversionContainer<ItemClass.SubService> buildingContainerSubService in buildingContainer.buildingSubServices)
                    {
                        if (buildingContainerSubService.storedItem_ == buildingSubService && buildingContainerSubService.validation_ == ItemInversionContainer<ItemClass.SubService>.ValidationType.None)
                        {
                            containerTags.Clear();
                            containerTags.AddRange(buildingContainer.tags);
                        }
                        else
                        {
                            validComparisons = false;
                        }
                    }

                    if (buildingContainer.useName && MapperOptionsManager.OptionChecked("buildingNames", MapperOptionsManager.exportOptions))
                    {
                        containerTags.Add(new OSMWayTag() { k = "name", v = buildingIngameName });
                    }

                    if (validComparisons)
                    {
                        if (containerTags.Count > 0)
                        {
                            buildingTags = containerTags;
                        }
                    }
                }
            }

            if(buildingTags.Count == 0)
            {
                buildingTags.Add(new OSMWayTag() { k = "building", v = "yes" });
                UniqueLogger.AddLog("Building names missing from search", building.Info.m_class.name, "");
            }

            buildingTags.Add(new OSMWayTag() { k = "layer", v = "1000" });

            return buildingTags.Count > 0;
        }

        /// <summary>
        /// Removes any crap data around the name of workshop items
        /// </summary>
        /// <param name="name">The object name to be printed</param>
        /// <returns>The cleaned up name</returns>
        public static string CleanUpName(string name)
        {
            Regex removeSteamworksData = new Regex("(?:[0-9]*\\.)(.*)(?:_Data.*)");
            Regex addSpacingOnUppercase = new Regex("([a-z]|[0-9])([A-Z])");

            name = removeSteamworksData.Replace(name, "$1");
            name = addSpacingOnUppercase.Replace(name, "$1 $2");

            return name;
        }
    }
}
